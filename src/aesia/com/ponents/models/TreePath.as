package aesia.com.ponents.models {
	/**
	 * @author Cédric Néhémie
	 */
	public class TreePath 	{		static public function pathTo ( node : TreeNode ) : TreePath		{			var n : TreeNode = node;			var p : Vector.<TreeNode> = Vector.<TreeNode> ( [ n ] );						while ( n.parent != null )			{				n = n.parent;				p.push( n );			}			p.reverse();			return new TreePath( p );		}		protected var _path : Vector.<TreeNode>;				public function TreePath ( ... args )		{			if( args.length == 1 && args[0] is Vector.<TreeNode> )			{				_path = args[0].concat();			}			else if( args.length > 1 )				_path = Vector.<TreeNode> ( args );			else				_path = new Vector.<TreeNode>();		}		public function getLastPathNode () : TreeNode		{			return _path[ _path.length - 1 ];		}		public function getPathNode ( index : int ) : TreeNode		{				return _path[ index ];		}		public function getParentPath () : TreePath		{			var p : Vector.<TreeNode> = _path.concat();			p.pop();			return new TreePath( p );		}		public function pathByAddingChild ( node : TreeNode ) : TreePath		{			return new TreePath( _path.concat().push( node ) );		}		public function isDescendant ( path : TreePath ) : Boolean		{			if( path.length <= length )				return false;			else			{				for( var i : Number = 0; i < length; i++ )				{					if( path.getPathNode( i ) != getPathNode( i ) )						return false;				}			}			return true;		}		public function contains ( node : TreeNode ) : Boolean		{			return _path.indexOf( node ) != -1;		}		public function clone () : TreePath { return new TreePath( path ); }		public function get path () : Vector.<TreeNode>	{ return _path.concat(); }		public function get length () : uint { return _path.length;	}				public function toString() : String 		{			return "TreePath["+_path.join("->")+"]";		}	}
}
