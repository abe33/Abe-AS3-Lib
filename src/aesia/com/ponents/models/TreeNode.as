package aesia.com.ponents.models {
	import aesia.com.ponents.events.ComponentEvent;	import aesia.com.ponents.events.ListEvent;	import aesia.com.ponents.events.TreeEvent;	import flash.events.Event;	import flash.events.EventDispatcher;	[Event(name="dataChange", type="trees.TreeEvent")]
	public class TreeNode extends EventDispatcher	{		protected var _parent : TreeNode;		protected var _userObject : *;		protected var _children : Vector.<TreeNode>;		protected var _allowChildren : Boolean;		protected var _path : TreePath;		protected var _expanded : Boolean;		protected var _expandable : Boolean;				static public function sortNodeAlphabeticallyFoldersBefore (a:TreeNode,b:TreeNode):int		{			if( !a.isLeaf && b.isLeaf )				return -1;			else if( a.isLeaf && !b.isLeaf )				return 1;			else if( String(a) > String(b) )				return 1;			else if( String(a) < String(b) )				return -1;			else				return 0;		}		static public function sortNodeAlphabetically (a:TreeNode,b:TreeNode):int		{			if( String(a) > String(b) )				return 1;			else if( String(a) < String(b) )				return -1;			else				return 0;		}		public function TreeNode ( obj : * = null, allowChildren : Boolean = true )		{			_children = new Vector.<TreeNode>();			_userObject = obj ? obj : "Node";			_allowChildren = allowChildren;			_expanded = false;			_expandable = true;		}				/*-----------------------------------------------------------------------		 * GETTER SETTER		 *----------------------------------------------------------------------*/		public function get children () : Vector.<TreeNode> { return _children.concat(); }		public function get depth () : Number { return path.length; }		public function get path () : TreePath { return _path ? _path : _path = TreePath.pathTo( this ); }		public function get root () : TreeNode { return path.getPathNode(0); }		public function get index () : int { return hasParent ? _parent.children.indexOf( this ) : -1; }		public function get isLeaf () : Boolean { return _children.length == 0; }		public function get isRoot () : Boolean { return path.length == 1; }		public function get isFirstChild () : Boolean { return hasParent ? _parent.children[ 0 ] == this : false; }		public function get isLastChild () : Boolean { return hasParent ? _parent.children[ _parent.children.length - 1 ] == this : false; }		public function get hasChildren () : Boolean { return _children.length != 0; }		public function get hasParent () : Boolean { return _parent != null; }		public function get expandable () : Boolean { return _expandable; }		public function set expandable (expandable : Boolean) : void		{			_expandable = expandable;		}		public function get parent () : TreeNode { return _parent; }		public function set parent ( node : TreeNode ) : void 		{			_parent = node;			if( _path && _parent )				_path = TreePath.pathTo( this );						for each( var n : TreeNode in _children )			{				n.parent = this;			}			fireDataChange( ListEvent.MOVE, path );		}		public function get userObject () : * {	return _userObject; }		public function set userObject ( obj : * ) : void 		{			_userObject = obj;			fireDataChange( ListEvent.SET, path );		}				public function get allowChildren () : Boolean { return _allowChildren; }				public function set allowChildren (allowChildren : Boolean) : void		{			_allowChildren = allowChildren;		}				public function get expanded () : Boolean { return _expanded; }				public function set expanded (expanded : Boolean) : void		{			_expanded = expanded;			if(!isLeaf && hasChildren)			{				fireDataChange();			}		}				/*-----------------------------------------------------------------------		 * CHILDREN HANDLING		 *----------------------------------------------------------------------*/				public function sort( f : Function ) : void 		{ 			_children = _children.sort( f ); 			for each ( var n : TreeNode in _children )				n.sort( f );		}				public function search( s : * ) : Array		{			var a : Array;			if( userObject == s || String(userObject).indexOf(s) != -1 )				a = [ path ];			else				a = [];			if( !isLeaf )				for each( var node : TreeNode in _children )					a = a.concat( node.search( s ) );			return a;		}				public function add ( node : TreeNode ) : void 		{			if( _allowChildren )			{				node.removeFromParent();				_children.push( node );				node.parent = this;				registerToTreeNodeEvents( node );				fireDataChange( ListEvent.ADD, path );			}		}		public function insert ( node : TreeNode, index : int ) : void 		{			if( _allowChildren )			{				node.removeFromParent();				if( index >= 0 && index < _children.length )				{					_children.splice( index, 0, node );					node.parent = this;					registerToTreeNodeEvents( node );					fireDataChange( ListEvent.ADD, path );				}				else					add( node );			}		}		public function remove ( node : TreeNode ) : void 		{			removeAt( _children.indexOf( node ) );		}		public function removeAt ( index : int ) : void 		{			if( _allowChildren )			{				if( index < 0 || index >= _children.length )					return;								var node : TreeNode = _children[ index ];				node.parent = null;				unregisterToTreeNodeEvents ( node );				_children.splice( index, 1 );				fireDataChange( ListEvent.REMOVE, path);			}		}		public function removeFromParent () : void 		{			if( !_parent ) return;						_parent.remove( this );			_parent = null;		}				public function removeAllChildren () : void		{			var l : Number = _children.length;			while( l-- )				removeAt(l);		}				public function isNodeChild ( node : TreeNode ) : Boolean		{			return node == _parent;		}				public function isNodeAncestor ( node : TreeNode ) : Boolean		{			return node.path.contains( this );		}		public function isNodeDescendant ( node : TreeNode ) : Boolean		{			if( node )				return path.isDescendant( node.path );			else				return false;		}		public function isNodeRelated ( node : TreeNode ) : Boolean		{			return root == node.root;		}					public function expandAll() : void		{			expanded = true;			for each( var n : TreeNode in _children )				n.expandAll();		}		public function collapseAll() : void		{			for each( var n : TreeNode in _children )				n.collapseAll();						expanded = false;		}		/*-----------------------------------------------------------------------		 * EVENTS HANDLING		 *----------------------------------------------------------------------*/				protected function change ( e : TreeEvent ) : void		{			fireDataChange( ListEvent.SET, e.path );		}				protected function fireDataChange ( action : uint = 0, p : TreePath = null ) : void		{			if( !p )				p = TreePath.pathTo( this );						dispatchEvent( new TreeEvent( ComponentEvent.DATA_CHANGE, action, p ) );		}				override public function dispatchEvent ( event : Event ) : Boolean		{			if( hasEventListener ( event.type ) || event.bubbles )				return super.dispatchEvent( event );			return false;		}		public function registerToTreeNodeEvents ( o : TreeNode ) : void		{			o.addEventListener( ComponentEvent.DATA_CHANGE, change );		}		public function unregisterToTreeNodeEvents ( o : TreeNode ) : void		{			o.removeEventListener( ComponentEvent.DATA_CHANGE, change );		}		override public function toString () : String		{			return String(_userObject);		}
	}
}
