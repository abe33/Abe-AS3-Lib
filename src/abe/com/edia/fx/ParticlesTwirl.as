/** * @license */package abe.com.edia.fx{	import abe.com.mon.core.Randomizable;
	import abe.com.mon.core.Allocable;	import abe.com.mon.core.LayeredSprite;	import abe.com.mon.core.Runnable;	import abe.com.mon.core.Suspendable;	import abe.com.mon.logs.Log;	import abe.com.mon.utils.AllocatorInstance;	import abe.com.mon.colors.Color;	import abe.com.mon.utils.MathUtils;	import abe.com.mon.randoms.Random;	import abe.com.mon.utils.RandomUtils;	import abe.com.motion.Impulse;	import abe.com.motion.ImpulseEvent;	import abe.com.motion.ImpulseListener;	import flash.display.GradientType;	import flash.display.Graphics;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.geom.Matrix;	import flash.utils.Dictionary;	/**	 * @author Cédric Néhémie	 */	public class ParticlesTwirl extends EventDispatcher implements ImpulseListener, Runnable, Suspendable, Allocable, Randomizable	{		protected var _isRunning : Boolean;				protected var particles : Dictionary;		protected var particlesCount : uint;		protected var time : int;		protected var step : Number;		protected var life : Number;		
		public var target : LayeredSprite;
		public var particlesColor : Color;
		public var particlesNum : uint;
		public var emissionDuration : Number;
		public var particlesTwirlRadiusMin : Number;		public var particlesTwirlRadiusMax : Number;
		public var particlesLifeMin : uint;
		public var particlesLifeMax : uint;		public var particlesAngularSpeedMin : uint;		public var particlesAngularSpeedMax : uint;
		public var particlesCreationRate : Number;
		public var particlesVerticalSpeedMin : Number;		public var particlesVerticalSpeedMax : Number;
		public var particlesVerticalStartMin : Number;		public var particlesVerticalStartMax : Number;		public var particlesRadiusMin : Number;		public var particlesRadiusMax : Number;		public var drawFunc : Function;
		public function ParticlesTwirl  ( target : LayeredSprite = null, 												  emissionDuration : Number = 2000, 										  drawFunc : Function = null,										  										  particlesNum : uint = 20,								  		  particlesCreationRate : Number = 150,										  particlesLifeMin : uint = 1000,										  particlesLifeMax : uint = 1500,										  particlesRadiusMin : uint = 3,										  particlesRadiusMax : uint = 6,										  particlesAngularSpeedMin : uint = 5,										  particlesAngularSpeedMax : uint = 8,								  		  particlesTwirlRadiusMin : Number = 10,								  		  particlesTwirlRadiusMax : Number = 15,										  particlesVerticalSpeedMin : Number = -20,										  particlesVerticalSpeedMax : Number = -30,										  particlesVerticalStartMin : Number = 15,										  particlesVerticalStartMax : Number = 20,										  										  										  particlesColor : Color = null										 ) 		{			this.target = target;			this.drawFunc = drawFunc != null ? drawFunc : draw; 			this.particlesColor = particlesColor ? particlesColor : Color.White;			this.particlesNum = particlesNum;			this.emissionDuration = emissionDuration;			this.particlesTwirlRadiusMin = particlesTwirlRadiusMin;			this.particlesTwirlRadiusMax = particlesTwirlRadiusMax;			this.particlesCreationRate = particlesCreationRate;			this.particlesLifeMin = particlesLifeMin;			this.particlesLifeMax = particlesLifeMax;			this.particlesRadiusMin = particlesRadiusMin;			this.particlesRadiusMax = particlesRadiusMax;			this.particlesAngularSpeedMin = particlesAngularSpeedMin;			this.particlesAngularSpeedMax = particlesAngularSpeedMax;			this.particlesVerticalSpeedMin = particlesVerticalSpeedMin;			this.particlesVerticalSpeedMax = particlesVerticalSpeedMax;			this.particlesVerticalStartMin = particlesVerticalStartMin;			this.particlesVerticalStartMax = particlesVerticalStartMax;			_randomSource = RandomUtils.RANDOM;		}		protected var _randomSource : Random;		public function get randomSource () : Random { return _randomSource; }		public function set randomSource (randomSource : Random) : void		{			_randomSource = randomSource;		}		public function tick (e : ImpulseEvent) : void		{			time += e.bias;			life += e.bias;						var p : Particle;			if( time > particlesCreationRate && life < emissionDuration )			{				if( particlesCount < particlesNum )				{					p = new Particle( _randomSource.random( MathUtils.PI2 ), 									  _randomSource.rangeAB( particlesAngularSpeedMin, particlesAngularSpeedMax ), 									  _randomSource.rangeAB( particlesLifeMin, particlesLifeMax ),									  _randomSource.rangeAB( particlesRadiusMin, particlesRadiusMax ),									  _randomSource.rangeAB( particlesVerticalStartMin, particlesVerticalStartMax ),									  _randomSource.rangeAB( particlesVerticalSpeedMin, particlesVerticalSpeedMax ),									  _randomSource.rangeAB( particlesTwirlRadiusMin, particlesTwirlRadiusMax )									 );										particlesCount++;					particles[p] = p;				}				time -= particlesCreationRate;			}						target.clearBackgroundGraphics();			target.clearForegroundGraphics();						for each ( p in particles ) 			{				p.life += e.bias;				if( p.life >= p.maxLife )				{					particlesCount--;					delete particles[p];				}				else				{					p.angle += p.angularSpeed * e.biasInSeconds;					if( p.angle > MathUtils.PI2 )						p.angle -= MathUtils.PI2;										p.y += p.yspeed * e.biasInSeconds;					var g : Graphics;								if( p.angle > Math.PI )						g = target.foreground.graphics;					else						g = target.background.graphics;											drawFunc( p, g );				}			}			if( life > emissionDuration && 				particlesCount == 0 )			{				stop();				dispatchEvent( new Event( Event.REMOVED ) );				AllocatorInstance.release( this );			}		}		protected function draw ( p : Particle, g : Graphics ) : void 		{			var s : Number = 1 - Math.abs( Math.cos( ( p.life / p.maxLife ) * Math.PI ) / 2 );						var m : Matrix = new Matrix();			var radius : Number = p.radius * s;			var d : Number = radius * 2;			m.createGradientBox( d, d, 0,  Math.cos( p.angle ) * p.twirlRadius - radius, p.y-radius );									g.beginGradientFill( GradientType.RADIAL, [ particlesColor.hexa, particlesColor.hexa ], 													  [ 1, 0 ],													  [ 0, 255 ], 													  m );			g.drawCircle( Math.cos( p.angle ) * p.twirlRadius, p.y, radius );			g.endFill();		}
		public function init () : void		{			if( !target )			{				/*FDT_IGNORE*/ CONFIG::DEBUG { /*FDT_IGNORE*/					Log.warn( "A ParticleTwirl object must have a valid target.");				/*FDT_IGNORE*/ } /*FDT_IGNORE*/				return;			}			time = 0;			life = 0;			particlesCount = 0;			particles = new Dictionary(true);									start();		}				public function dispose () : void		{			particles = null,						target.foreground.graphics.clear();			target.background.graphics.clear();						stop();		}				public function isRunning () : Boolean		{			return _isRunning;		}				public function start () : void		{			if( !_isRunning )			{				_isRunning = true;				Impulse.register( tick );			}		}		public function stop () : void		{			if( _isRunning )			{				Impulse.unregister( tick );				_isRunning = false;			}		}	}}internal class Particle {	public var angle : Number;	public var angularSpeed : Number;	public var life : Number;	public var maxLife : Number;	public var y : Number;	public var yspeed : Number;
	public var radius : Number;	public var twirlRadius : Number;
	public function Particle( angle : Number = 0, 							  angularSpeed : Number = .1,							  maxLife : Number = 100,							  radius : Number = 4,							  y : Number = 0,							  yspeed : Number = -10,							  twirlRadius : Number = 30							   )	{		this.angle = angle;		this.angularSpeed = angularSpeed;		this.maxLife = maxLife;		this.y = y;		  		this.yspeed = yspeed;			this.life = 0;				this.radius = radius; 			this.twirlRadius = twirlRadius; 		}}