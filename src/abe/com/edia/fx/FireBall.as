/** * @license */package abe.com.edia.fx{	import abe.com.mon.colors.Color;	import abe.com.mon.core.Allocable;	import abe.com.mon.core.LayeredSprite;	import abe.com.mon.core.Randomizable;	import abe.com.mon.core.Runnable;	import abe.com.mon.core.Suspendable;	import abe.com.mon.geom.Ellipsis;	import abe.com.mon.logs.Log;	import abe.com.mon.randoms.Random;	import abe.com.mon.utils.RandomUtils;	import abe.com.motion.Impulse;	import abe.com.motion.ImpulseListener;	import abe.com.motion.easing.Linear;	import abe.com.motion.easing.Quint;	import flash.display.GradientType;	import flash.display.Graphics;	import flash.filters.BlurFilter;	import flash.filters.GlowFilter;	import flash.geom.Matrix;	import flash.geom.Point;	/**	 * @author Cédric Néhémie	 */	public class FireBall implements ImpulseListener, Runnable, Suspendable, Allocable, Randomizable	{		protected var _isRunning : Boolean;		private var ms : Number;				public var angle : Number;		public var angleSpeed : Number;		public var ellipse : Ellipsis;		public var slicesNum : Number;		public var slicesLength : Number;		public var sliceSegments : Number;		public var slices : Vector.<Flame>;		public var target : LayeredSprite;		public var yoffset : Number;		public var blured : Boolean;		public function FireBall  ( 								    target : LayeredSprite = null, 									ellipsis : Ellipsis = null,									angleSpeed : Number = .3,									slicesNum : Number = 24,									slicesLength : Number = 10,									sliceSegments : Number = 16,									yoffset : Number = 0,									blured : Boolean = false								  ) 		{			this.angleSpeed = angleSpeed;			this.target = target;			this.ellipse = ellipsis ? ellipsis : new Ellipsis( 0, 0, 30, 15 );			this.sliceSegments = sliceSegments;			this.slicesLength = slicesLength;			this.slicesNum = slicesNum;			this.yoffset = yoffset;			this.blured = blured;			_randomSource = RandomUtils.RANDOM;		}		protected var _randomSource : Random;		public function get randomSource () : Random { return _randomSource; }		public function set randomSource (randomSource : Random) : void		{			_randomSource = randomSource;		}		public function tick (bias : Number, biasInSeconds : Number, current : Number) : void		{			var pi : Number = Math.PI ;			var pi2 : Number = pi * 2;			var skew : Number = angleSpeed * pi;			var asize : Number = pi2/7;						var aa : Number = angle, a1 : Number, a2 : Number, a3 : Number, a4 : Number, a5 : Number, a6 : Number;			var m1 : Number, m2 : Number, m3 : Number;			var pt1 : Point, pt2 : Point, pt3 : Point, pt4 : Point, pt5 : Point, pt6 : Point;						var cfg : Graphics = target.foreground.graphics;			var cbg : Graphics = target.background.graphics;			var g : Graphics;			var m : Matrix = new Matrix();			target.clearBackgroundGraphics();			target.clearForegroundGraphics();						for each( var pt : Flame in slices )			{				var aasize : Number = asize * (( 1 - pt.life ));				aa = pt.angle;								a1 = aa - aasize* (( 1 - pt.life ));				a2 = aa - aasize*1.3 + skew/2;				a3 = aa - aasize*.2 + skew;				a4 = aa + aasize* (( 1 - pt.life ));				a5 = aa + aasize*1.3 + skew/2;				a6 = aa + aasize*.2 + skew;				pt1 = ellipse.getPointAtAngle(a1);				pt2 = ellipse.getPointAtAngle(a2);				pt3 = ellipse.getPointAtAngle(a3);				pt4 = ellipse.getPointAtAngle(a4);				pt5 = ellipse.getPointAtAngle(a5);				pt6 = ellipse.getPointAtAngle(a6);								g = pt1.y > 0 ? cfg : cbg;				var h1 : Number = Quint.easeIn(pt.life, 0, pt.height, 1 );				var h2 : Number = Linear.easeIn(pt.life, 0, pt.height, 1 );				var h3 : Number = h1 + ( h2-h1 ) / 2;				var aa1: Number = pi*.2 + (h1 / pt.height) * pi*1.5;				var aa2: Number = pi*.2 + (h3 / pt.height) * pi*1.5;				var aa3: Number = pi*.2 + (h2 / pt.height) * pi*1.5;				m1 = ( 1.5+Math.sin( aa1 ) )/2.5 * pt.radius;				m2 = ( 1.5+Math.sin( aa2 ) )/2.5 * pt.radius;				m3 = ( 1.5+Math.sin( aa3 ) )/2.5 * pt.radius;								m.createGradientBox( 30, h2-h1, pi/2, 0, pt1.y - h2 );				//g.beginFill(Color.Yellow.hexa, .5);							g.beginGradientFill( GradientType.LINEAR, 											[ Color.Yellow.hexa, Color.Yellow.hexa, Color.Yellow.hexa ],											[ 0, .7, .2 ],											[ 0, 120 ,255 ], 											m, "pad" );												// first quadran 1				g.moveTo(pt1.x*m1, pt1.y*m1-h1 + yoffset);				g.curveTo(pt2.x*m2, pt2.y*m2-h3 + yoffset, pt3.x*m3, pt3.y*m3-h2 + yoffset );				g.lineTo( pt6.x*m3, pt6.y*m3-h2 + yoffset );				g.curveTo( pt5.x*m2, pt5.y*m2-h3 + yoffset, pt4.x*m1, pt4.y*m1-h1 + yoffset);				g.endFill();												pt.life += biasInSeconds;				pt.angle += angleSpeed * pi2 * biasInSeconds;				if( pt.life > 1 )				{					pt.life = _randomSource.random()/4;					pt.angle = _randomSource.random()*pi2;					pt.height = 50 + _randomSource.random() * 50;					pt.radius = 0.5+_randomSource.random()/2;				}			}				//angle += angleSpeed * pi2 * e.biasInSeconds;		}				public function init () : void		{			if( !target )			{				/*FDT_IGNORE*/ CONFIG::DEBUG { /*FDT_IGNORE*/					Log.warn( "A FireBall object must have a valid target.");				/*FDT_IGNORE*/ } /*FDT_IGNORE*/				return;			}						this.angle = 0;			this.ms = 0;			this.slices = new Vector.<Flame>( slicesNum );						if( blured )			{				target.foreground.filters = [new GlowFilter ( Color.Red.hexa, 1, 6,6,1.5,1),new BlurFilter(2,2)];				target.background.filters = [new GlowFilter ( Color.Red.hexa, 1, 6,6,1.5,1),new BlurFilter(2,2)];			}			else			{				this.target.background.filters = [ new GlowFilter ( Color.Red.hexa, 1, 6,6,1.5,1) ];				this.target.foreground.filters = [ new GlowFilter ( Color.Red.hexa, 1, 6,6,1.5,1) ];			}						while( slicesNum-- )				slices[slicesNum] = new Flame( _randomSource );			start();		}				public function dispose () : void		{			slices = null;			this.target.background.filters = [];			this.target.foreground.filters = [];			stop();		}				public function isRunning () : Boolean		{			return _isRunning;		}				public function start () : void		{			if( !_isRunning )			{				_isRunning = true;				Impulse.register( tick );			}		}		public function stop () : void		{			if( _isRunning )			{				Impulse.unregister( tick );				_isRunning = false;			}		}	}}import abe.com.mon.randoms.Random;internal class Flame{	public var life : Number;	public var angle : Number;	public var height : Number;	public var radius : Number;		public function Flame ( randomSource : Random )	{		life = randomSource.random();		angle = randomSource.random() * Math.PI*2;		height = 50 + randomSource.random() * 50;		radius = 0.5+randomSource.random()/2;	}}