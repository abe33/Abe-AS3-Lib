/** * @license */package abe.com.edia.fx{	import abe.com.mon.colors.Color;	import abe.com.mon.core.Allocable;	import abe.com.mon.core.LayeredSprite;	import abe.com.mon.core.Randomizable;	import abe.com.mon.core.Runnable;	import abe.com.mon.core.Suspendable;	import abe.com.mon.logs.Log;	import abe.com.mon.randoms.Random;	import abe.com.mon.utils.AllocatorInstance;	import abe.com.mon.utils.MathUtils;	import abe.com.mon.utils.RandomUtils;	import abe.com.motion.Impulse;	import abe.com.motion.ImpulseListener;	import flash.display.Graphics;	import flash.utils.Dictionary;		import org.osflash.signals.Signal;	/**	 * @author Cédric Néhémie	 */	public class TwirlRibbons implements ImpulseListener, Runnable, Suspendable, Allocable, Randomizable	{		protected var _isRunning : Boolean;				protected var ribbons : Dictionary;		protected var ribbonsCount : uint;		protected var time : int;		protected var step : Number;		protected var life : Number;				public var target : LayeredSprite;				public var emissionDuration : Number;		public var drawFunc : Function;				public var ribbonsColor : Color;		public var ribbonsNum : uint;		public var ribbonsTwirlRadiusMin : Number;		public var ribbonsTwirlRadiusMax : Number;		public var ribbonsLifeMin : Number;		public var ribbonsLifeMax : Number;		public var ribbonsSegmentsMin : uint;		public var ribbonsSegmentsMax : uint;		public var ribbonsAngularSpeedMin : Number;		public var ribbonsAngularSpeedMax : Number;		public var ribbonsCreationRate : Number;		public var ribbonsVerticalSpeedMin : Number;		public var ribbonsVerticalSpeedMax : Number;		public var ribbonsVerticalStartMin : Number;		public var ribbonsVerticalStartMax : Number;		public var ribbonsThicknessMin : Number;		public var ribbonsThicknessMax : Number;		public var ribbonsSegmentsAngleMin : Number;		public var ribbonsSegmentsAngleMax : Number;		public var ribbonsSegmentsHeightMin : Number;		public var ribbonsSegmentsHeightMax : Number;				protected var _removed : Signal;		public function get removed () : Signal { return _removed; }		public function TwirlRibbons  ( target : LayeredSprite = null,																				emissionDuration : Number = 2000, 										drawFunc : Function = null,										ribbonsCreationRate : Number = 500, 										ribbonsNum : uint = 6,										ribbonsLifeMin : Number = 1000,										ribbonsLifeMax : Number = 1500,										ribbonsThicknessMin : Number = 2,										ribbonsThicknessMax : Number = 4,										ribbonsSegmentsMin : uint = 8,										ribbonsSegmentsMax : uint = 12,										ribbonsSegmentsAngleMin : Number = .5,										ribbonsSegmentsAngleMax : Number = .7,										ribbonsSegmentsHeightMin : Number = 2,										ribbonsSegmentsHeightMax : Number = 4,										ribbonsAngularSpeedMin : Number = 5,										ribbonsAngularSpeedMax : Number = 8,								  		ribbonsTwirlRadiusMin : Number = 12,								  		ribbonsTwirlRadiusMax : Number = 22,										ribbonsVerticalSpeedMin : Number = -20,										ribbonsVerticalSpeedMax : Number = -30,										ribbonsVerticalStartMin : Number = 8,										ribbonsVerticalStartMax : Number = 12,										  										  										ribbonsColor : Color = null									  ) 		{		    _removed = new Signal();			this.target = target;			this.drawFunc = drawFunc != null ? drawFunc : draw; 						this.emissionDuration = emissionDuration;			this.ribbonsCreationRate = ribbonsCreationRate;			this.ribbonsColor = ribbonsColor ? ribbonsColor : Color.White;			this.ribbonsNum = ribbonsNum;			this.ribbonsTwirlRadiusMin = ribbonsTwirlRadiusMin;			this.ribbonsTwirlRadiusMax = ribbonsTwirlRadiusMax;			this.ribbonsCreationRate = ribbonsCreationRate;			this.ribbonsLifeMin = ribbonsLifeMin;			this.ribbonsLifeMax = ribbonsLifeMax;			this.ribbonsThicknessMin = ribbonsThicknessMin;			this.ribbonsThicknessMax = ribbonsThicknessMax;			this.ribbonsAngularSpeedMin = ribbonsAngularSpeedMin;			this.ribbonsAngularSpeedMax = ribbonsAngularSpeedMax;			this.ribbonsVerticalSpeedMin = ribbonsVerticalSpeedMin;			this.ribbonsVerticalSpeedMax = ribbonsVerticalSpeedMax;			this.ribbonsVerticalStartMin = ribbonsVerticalStartMin;			this.ribbonsVerticalStartMax = ribbonsVerticalStartMax;			this.ribbonsSegmentsMin = ribbonsSegmentsMin;			this.ribbonsSegmentsMax = ribbonsSegmentsMax;			this.ribbonsSegmentsAngleMin = ribbonsSegmentsAngleMin;			this.ribbonsSegmentsAngleMax = ribbonsSegmentsAngleMax;			this.ribbonsSegmentsHeightMin = ribbonsSegmentsHeightMin;			this.ribbonsSegmentsHeightMax = ribbonsSegmentsHeightMax;			_randomSource = RandomUtils;        }        protected var _randomSource : Random;		public function get randomSource () : Random { return _randomSource; }		public function set randomSource (randomSource : Random) : void		{			_randomSource = randomSource;		}				public function tick (bias : Number, biasInSeconds : Number, time : Number) : void		{			time += bias;			life += bias;						var p : Ribbon;			if( time > ribbonsCreationRate && life < emissionDuration )			{				if( ribbonsCount < ribbonsNum )				{					p = new Ribbon( 									 _randomSource.irangeAB( ribbonsSegmentsMin, ribbonsSegmentsMax ), 									 _randomSource.rangeAB( ribbonsSegmentsAngleMin, ribbonsSegmentsAngleMax ), 									 _randomSource.rangeAB( ribbonsSegmentsHeightMin, ribbonsSegmentsHeightMax ), 									 _randomSource.random( MathUtils.PI2 ), 									 _randomSource.rangeAB( ribbonsAngularSpeedMin, ribbonsAngularSpeedMax ), 									 _randomSource.rangeAB( ribbonsVerticalSpeedMin, ribbonsVerticalSpeedMax ),									 _randomSource.rangeAB( ribbonsLifeMin, ribbonsLifeMax ),									 _randomSource.rangeAB( ribbonsThicknessMin, ribbonsThicknessMax ),									 _randomSource.rangeAB( ribbonsVerticalStartMin, ribbonsVerticalStartMax ),									 _randomSource.rangeAB( ribbonsVerticalSpeedMin, ribbonsVerticalSpeedMax ),									 _randomSource.rangeAB( ribbonsTwirlRadiusMin, ribbonsTwirlRadiusMax )									);										ribbonsCount++;					ribbons[p] = p;				}				time -= ribbonsCreationRate;			}						target.clearBackgroundGraphics();			target.clearForegroundGraphics();						for each ( p in ribbons ) 			{				p.life += bias;				if( p.life >= p.maxLife )				{					p.deadSegments -= Math.abs(p.verticalSpeed/2) * biasInSeconds;										if( p.deadSegments < 0 )					{						ribbonsCount--;						delete ribbons[p];						continue;					}				}								p.angle += p.angularSpeed * biasInSeconds;				if( p.angle > MathUtils.PI2 )					p.angle -= MathUtils.PI2;								p.y += p.yspeed * biasInSeconds;									drawFunc( p, target );			}			if( life > emissionDuration && 				ribbonsCount == 0 )			{				stop();				_removed.dispatch( this );				AllocatorInstance.release( this );			}		}				public function init () : void		{						if( !target )			{				/*FDT_IGNORE*/ CONFIG::DEBUG { /*FDT_IGNORE*/					Log.warn( "A TwirlRibbons object must have a valid target.");				/*FDT_IGNORE*/ } /*FDT_IGNORE*/				return;			}						time = 0;			life = 0;			ribbonsCount = 0;			ribbons = new Dictionary(true);			start();		}				public function dispose () : void		{			stop();		}				public function isRunning () : Boolean		{			return _isRunning;		}				public function start () : void		{			if( !_isRunning )			{				_isRunning = true;				Impulse.register( tick );			}		}		public function stop () : void		{			if( _isRunning )			{				Impulse.unregister( tick );				_isRunning = false;			}		}		protected function draw ( p : Ribbon, o : LayeredSprite ) : void 		{			var g : Graphics;						for( var i : int = 0; i < p.segments; i++ )			{				var s : Number = 1 - Math.abs( Math.cos( ( i / p.segments ) * Math.PI ) / 2 );								var astart : Number = p.angle + i * p.segmentsAngle;				var h : Number = p.segments * p.segmentsHeight;				var y : Number = i * p.segmentsHeight;								if( astart > MathUtils.PI2 )					astart -= MathUtils.PI2;										if(  astart + p.segmentsAngle > Math.PI )					g = o.foreground.graphics;				else					g = o.background.graphics;				var x1 : Number = Math.cos( astart ) * p.twirlRadius;				var x2 : Number = Math.cos( astart + p.segmentsAngle) * p.twirlRadius;				var y1 : Number = p.y + h - y;				var y2 : Number = p.y + h - y - p.segmentsHeight;								g.beginFill( ribbonsColor.hexa );								if( i >= p.deadSegments || y2 > p.ystart + p.segmentsHeight * 2 )	{}				else if( i == 0 || 						 y2 + p.segmentsHeight > p.ystart + p.segmentsHeight * 2						)				{					g.moveTo( x1, y1 );					g.lineTo( x2, y2 - p.thickness * s / 2 );						g.lineTo( x2, y2 + p.thickness * s / 2 );						g.lineTo( x1, y1 );					}				else if( i + 1 >= p.deadSegments )				{					g.moveTo( x1, y1 - p.thickness * s / 2 );					g.lineTo( x2, y2 );						g.lineTo( x1, y1 + p.thickness * s / 2 );						g.lineTo( x1, y1 );					}				else				{					g.moveTo( x1, y1 - p.thickness * s / 2 );					g.lineTo( x2, y2 - p.thickness * s / 2 );					g.lineTo( x2, y2 + p.thickness * s / 2 );					g.lineTo( x1, y1 + p.thickness * s / 2 );					g.lineTo( x1, y1 - p.thickness * s / 2 );				}				g.endFill();			}		}	}}internal class Ribbon{	public var segments : uint;	public var angle : Number;	public var angularSpeed : Number;	public var verticalSpeed : Number;	public var maxLife : Number;	public var life : Number;	public var y : Number;	public var yspeed : Number;	public var thickness : Number;	public var twirlRadius : Number;	public var segmentsAngle : Number;	public var segmentsHeight : Number;	public var deadSegments : Number ;	public var ystart : Number;	public function Ribbon ( segments : uint = 5,							 segmentsAngle : Number = .15,							 segmentsHeight : Number = 5,							 angle : Number = 0,							 angularSpeed : Number = .15,							 verticalSpeed : Number = -20,							 maxLife : Number = 1500,							 thickness : Number = 4,							 y : Number = 0,							 yspeed : Number = -10,							 twirlRadius : Number = 30 ) 	{		this.segments = segments;		this.segmentsAngle = segmentsAngle;		this.segmentsHeight = segmentsHeight;		this.angle = angle;		this.angularSpeed = angularSpeed;		this.verticalSpeed = verticalSpeed;		this.maxLife = maxLife;		this.y = this.ystart = y;		  		this.yspeed = yspeed;			this.thickness = thickness; 			this.twirlRadius = twirlRadius; 				this.life = 0;		this.deadSegments = segments;		}}