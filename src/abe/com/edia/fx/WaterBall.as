package abe.com.edia.fx{	import abe.com.mon.colors.Color;	import abe.com.mon.core.Allocable;	import abe.com.mon.core.LayeredSprite;	import abe.com.mon.core.Runnable;	import abe.com.mon.core.Suspendable;	import abe.com.mon.geom.Ellipsis;	import abe.com.mon.logs.Log;	import abe.com.motion.Impulse;	import abe.com.motion.ImpulseListener;	import flash.display.GradientType;	import flash.display.SpreadMethod;	import flash.display.Sprite;	import flash.filters.BlurFilter;	import flash.geom.Matrix;	import flash.geom.Point;	/**	 * @author Cédric Néhémie	 */	public class WaterBall implements ImpulseListener, Runnable, Suspendable, Allocable	{		protected var _isRunning : Boolean;		protected var ms : Number;				public var angle : Number;		public var angleSpeed : Number;		public var ellipse : Ellipsis;		public var slicesNum : Number;		public var slicesLength : Number;		public var sliceSegments : Number;		public var target : LayeredSprite;		public var drawLights : Boolean;		public var yoffset : Number;		public var waterColor1 : Color;		public var waterColor2 : Color;		public var foamColor : Color;		public var blured : Boolean;		public function WaterBall  ( target : LayeredSprite = null,									 ellipsis : Ellipsis = null,									 waterColor1 : Color = null,									 waterColor2 : Color = null,									 foamColor : Color = null,								  	 angleSpeed : Number = 10,								  	 slicesNum : Number = 11,								  	 slicesLength : Number = 10,								 	 sliceSegments : Number = 16,								 	 drawLights : Boolean = true,								 	 yoffset : Number = 0,								 	 blured : Boolean = false								 	) 		{			this.target = target;			this.waterColor1 = waterColor1 ? waterColor1 : Color.PaleTurquoise;			this.waterColor2 = waterColor2 ? waterColor2 : Color.CadetBlue;			this.foamColor = foamColor ? foamColor : Color.White;			this.angleSpeed = angleSpeed;			this.ellipse = ellipsis ? ellipsis : new Ellipsis( 0, 0, 40, 20 );			this.sliceSegments = sliceSegments;			this.slicesLength = slicesLength;			this.slicesNum = slicesNum;			this.drawLights = drawLights;			this.yoffset = yoffset;			this.blured = blured;		}		public function tick (bias : Number, biasInSeconds : Number, time : Number) : void		{			var pi : Number = Math.PI ;			var pi2 : Number = pi * 2;			var sliceSegSize : Number = pi2 / sliceSegments;			var y : Number = ellipse.radius1 / 1.3;			var sliceDist : Number = ellipse.radius1 / slicesNum;						target.clearBackgroundGraphics();			target.clearForegroundGraphics();						var m : Matrix = new Matrix();			var er12 : Number = ellipse.radius1*2;			var er22 : Number = ellipse.radius2*2;						if( drawLights )			{				m.createGradientBox( er12, er22, 0, -ellipse.radius1, -ellipse.radius2 + yoffset );									target.background.graphics.clear();				target.background.graphics.beginGradientFill( GradientType.RADIAL, 												[ waterColor1.hexa, waterColor2.hexa ],												[ 1, 0 ],												//[ Math.floor(ll*50), 1 + Math.floor(ll*254) ], 												[ 100, 255 ], 												m, 												SpreadMethod.PAD );										target.background.graphics.drawEllipse( -ellipse.radius1, -ellipse.radius2 + yoffset, er12, er22 );				target.background.graphics.endFill();						}				m.createGradientBox( er12, er12, 0, -ellipse.radius1, -ellipse.radius1*1.8 + yoffset );										target.foreground.graphics.beginGradientFill( GradientType.RADIAL, 											[ waterColor2.hexa, waterColor1.hexa ],											[ .6, .7 ],											//[ Math.floor(ll*50), 1 + Math.floor(ll*254) ], 											[ 230, 245 ], 											m, 											SpreadMethod.PAD );								//target.foreground.graphics.beginFill( Color.CadetBlue.hexa, .7 );			target.foreground.graphics.drawEllipse( -ellipse.radius1, -ellipse.radius1*1.8 + yoffset, er12, er12  );			target.foreground.graphics.endFill();						var dob : Sprite;			var a : Number = angle;			for( var j : Number = 0; j < slicesNum ; j++, a += sliceDist*2.53 )			{				y = ( ( j * sliceDist * 1.7 ) + a ) % ( ellipse.radius1*1.6 );								var rr : Number = 0.1 + ( y / ( ellipse.radius1*2 ) )*0.9;				for( var i : Number  = 0; i < slicesLength ; i++ )				{					var p1 : Point = ellipse.getPointAtAngle( a + ( sliceSegSize )*i );					var p2 : Point = ellipse.getPointAtAngle( a + ( sliceSegSize )*(i+1) );					var alpha : Number;										if( p1.y - ellipse.y > 0 )					{						dob = target.foreground;						alpha = .8;					}					else 					{						dob = target.background;						alpha = .4;					}										p1.x *= Math.abs( Math.sin( rr * pi ) );					p1.y *= Math.abs( Math.sin( rr * pi ) );					p2.x *= Math.abs( Math.sin( rr * pi ) );					p2.y *= Math.abs( Math.sin( rr * pi ) );										dob.graphics.lineStyle( 2 + Math.sin(a*2.5 + ( sliceSegSize )*(i+1) ) , foamColor.hexa, alpha );					dob.graphics.moveTo( p1.x, ellipse.radius1*0.22 + p1.y - y - i +  yoffset );					dob.graphics.lineTo( p2.x, ellipse.radius1*0.22 + p2.y - y -( i + 1 ) + yoffset );				}			}			angle += angleSpeed * biasInSeconds;		}		public function init () : void		{			if( !target )			{				/*FDT_IGNORE*/ CONFIG::DEBUG { /*FDT_IGNORE*/					Log.warn( "A WaterBall object must have a valid target.");				/*FDT_IGNORE*/ } /*FDT_IGNORE*/				return;			}						this.angle = 0;			this.ms = 0;			start();			if( blured )			{				target.foreground.filters = [new BlurFilter(2,2)];				target.background.filters = [new BlurFilter(2,2)];			}		}				public function dispose () : void		{			target.foreground.filters = [];			target.background.filters = [];			stop();		}				public function isRunning () : Boolean		{			return _isRunning;		}				public function start () : void		{			if( !_isRunning )			{				_isRunning = true;				Impulse.register( tick );			}		}		public function stop () : void		{			if( _isRunning )			{				Impulse.unregister( tick );				_isRunning = false;			}		}	}}