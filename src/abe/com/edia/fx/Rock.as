/** * @license */package abe.com.edia.fx{	import abe.com.mon.core.Randomizable;
	import abe.com.mon.core.Allocable;	import abe.com.mon.core.Runnable;	import abe.com.mon.core.Suspendable;	import abe.com.mon.geom.Circle;	import abe.com.mon.utils.AllocatorInstance;	import abe.com.mon.colors.Color;	import abe.com.mon.utils.MathUtils;	import abe.com.mon.randoms.Random;	import abe.com.mon.utils.RandomUtils;	import abe.com.motion.Impulse;	import abe.com.motion.ImpulseEvent;	import abe.com.motion.ImpulseListener;	import flash.display.Shape;	import flash.events.Event;	import flash.geom.Point;	/**	 * @author Cédric Néhémie	 */	public class Rock extends Shape implements ImpulseListener, Runnable, Suspendable, Allocable, Randomizable	{		protected var _isRunning : Boolean;				public var color : Color;
		public var shadowColor : Color;
		public var size : Number;		public var safeSize : Number;
		public var maxLife : Number;
		public var life : Number;		public var edges : uint;
		public var seed : uint;
		public var lodLevels : uint;
		public var currentLod : uint;		public var velocity : Point;
		public var gravity : Point;		public var friction : Number;				public function Rock  ( color : Color = null, 								shadowColor : Color = null,								size : Number = 15,								maxLife : Number = 2000,								edges : uint = 5,								lodLevels : uint = 4,								velocity : Point = null,								gravity : Point = null,								friction : Number = 1							   ) 		{			this.color = color ? color : Color.Peru;			this.shadowColor = shadowColor ? shadowColor : Color.SaddleBrown;			this.size = size;			this.maxLife = maxLife;			this.edges = edges;			this.lodLevels = lodLevels;			this.velocity = velocity;			this.gravity = gravity;			this.friction = friction;			_randomSource = RandomUtils.RANDOM;		}		protected var _randomSource : Random;		public function get randomSource () : Random { return _randomSource; }		public function set randomSource (randomSource : Random) : void		{			_randomSource = randomSource;		}		public function tick (e : ImpulseEvent) : void		{			life += e.bias;			var lod : uint = Math.floor( life / maxLife * lodLevels );									x += velocity.x * e.biasInSeconds;			y += velocity.y * e.biasInSeconds;						velocity.x *= friction;			velocity.y *= friction;						velocity.x += gravity.x * e.biasInSeconds;			velocity.y += gravity.y * e.biasInSeconds;						if( lod != currentLod )			{				size -= safeSize * ( 1 / lodLevels );				currentLod = lod;				draw();			}						if( life > maxLife )			{ 				if( parent )				{					if( parent.contains( this ) )						parent.removeChild( this );				}				stop();				this.graphics.clear();				dispatchEvent( new Event( Event.REMOVED ) );				AllocatorInstance.release( this );			}		}				public function init () : void		{			life = 0;			currentLod = 0;			safeSize = size;			draw();			start();		}		protected function draw () : void 		{			graphics.clear();						var c : Circle;			var pt : Point;			var opt : Point;			var i : int;			// shadows			c = new Circle( 0, 0, size/2 );			opt = c.getPointAtAngle(0);			opt = _randomSource.point(opt, size/6 );						graphics.beginFill( shadowColor.hexa );			graphics.moveTo(opt.x, opt.y);									for( i = 1 ; i < edges ; i++)			{				pt = c.getPointAtAngle( i / edges * MathUtils.PI2 );				pt = _randomSource.point(pt, size/6 );								graphics.lineTo( pt.x, pt.y );			}
			graphics.lineTo(opt.x, opt.y);			graphics.endFill();						// lights			c = new Circle( -size/8, - size/5, size/3 );			opt = c.getPointAtAngle(0);			opt = _randomSource.point(opt, size/6 );						graphics.beginFill( color.hexa );			graphics.moveTo(opt.x, opt.y);									for( i = 1 ; i < edges ; i++)			{				pt = c.getPointAtAngle( i / edges * MathUtils.PI2 );				pt = _randomSource.point(pt, size/6 );								graphics.lineTo( pt.x, pt.y );							}			graphics.lineTo(opt.x, opt.y);			graphics.endFill();		}
		public function dispose () : void		{			stop();			graphics.clear();		}				public function isRunning () : Boolean		{			return _isRunning;		}				public function start () : void		{			if( !_isRunning )			{				_isRunning = true;				Impulse.register( tick );			}		}		public function stop () : void		{			if( _isRunning )			{				Impulse.unregister( tick );				_isRunning = false;			}		}	}}