/** * @license */package abe.com.edia.fx{	import abe.com.mon.colors.Color;	import abe.com.mon.core.Allocable;	import abe.com.mon.core.Randomizable;	import abe.com.mon.core.Runnable;	import abe.com.mon.core.Suspendable;	import abe.com.mon.geom.Path;	import abe.com.mon.geom.pt;	import abe.com.mon.randoms.Random;	import abe.com.mon.utils.MathUtils;	import abe.com.mon.utils.RandomUtils;	import abe.com.motion.Impulse;	import abe.com.motion.ImpulseEvent;	import abe.com.motion.ImpulseListener;	import abe.com.motion.easing.Cubic;	import flash.display.Shape;	import flash.geom.Point;	import flash.utils.Dictionary;	/**	 * @author Cédric Néhémie	 */	public class LightningBolt extends Shape implements ImpulseListener, Runnable, Suspendable, Allocable, Randomizable	{		protected var _isRunning : Boolean;		protected var _particles : Dictionary;				public var path : Path;		public var pathStart : Number;
		public var pathEnd : Number;				public var segmentCount : Number;		public var subSegmentCount : Number;				public var lineThickness : Number;		public var lineColor : Color;				public var randomAmount : Number;
				public var generateParticles : Boolean;
		public var particlesRate : Number;		public var particlesRadiusMin : Number;		public var particlesRadiusMax : Number;		public var particlesLifeMin : Number;		public var particlesLifeMax : Number;		public var particlesVelocityMin : Number;		public var particlesVelocityMax : Number;		public var particlesGravity : Point;		public var particlesFriction : Number;
		public var particlesSalveCount : int;
		public function LightningBolt  ( path : Path, 										 lineThickness : Number = 1,										 lineColor : Color = null,										 pathStart : Number = 0,										 pathEnd : Number = 1,										 segmentCount : Number = 5,										 subSegmentCount : Number = 5,										 randomAmount : Number = 10,										 generateParticles : Boolean = true,										 particlesRate : Number = .01,										 particlesSalveCount : int = 5,										 particlesRadiusMin : Number = 1,										 particlesRadiusMax : Number = 2,										 particlesLifeMin : Number = 500,										 particlesLifeMax : Number = 1000,										 particlesVelocityMin : Number = 20,										 particlesVelocityMax : Number = 30,										 particlesGravity : Point = null,										 particlesFriction : Number = .95									 	) 		{			this.path = path;			this.pathStart = pathStart;			this.pathEnd = pathEnd;						this.lineThickness = lineThickness;			this.lineColor = lineColor ? lineColor : Color.White;						this.segmentCount = segmentCount;			this.subSegmentCount = subSegmentCount;						this.randomAmount = randomAmount;						this.generateParticles = generateParticles;			this.particlesRate = particlesRate;			this.particlesSalveCount = particlesSalveCount;			this.particlesRadiusMin = particlesRadiusMin;			this.particlesRadiusMax = particlesRadiusMax;			this.particlesLifeMin = particlesLifeMin;			this.particlesLifeMax = particlesLifeMax;			this.particlesVelocityMin = particlesVelocityMin;			this.particlesVelocityMax = particlesVelocityMax;			this.particlesGravity = particlesGravity ? particlesGravity : pt(0,20);			this.particlesFriction = particlesFriction;			_randomSource = RandomUtils.RANDOM;		}		protected var _randomSource : Random;		public function get randomSource () : Random { return _randomSource; }		public function set randomSource (randomSource : Random) : void		{			_randomSource = randomSource;		}		public function tick (e : ImpulseEvent) : void		{			moveParticles( e );						draw();		}
		public function init () : void		{			if( generateParticles )				_particles = new Dictionary(true);						start();		}				public function dispose () : void		{			_particles = null;			this.graphics.clear();			stop();		}				public function isRunning () : Boolean		{			return _isRunning;		}				public function start () : void		{			if( !_isRunning )			{				_isRunning = true;				Impulse.register( tick );			}		}		public function stop () : void		{			if( _isRunning )			{				Impulse.unregister( tick );				_isRunning = false;			}		}				protected function moveParticles ( e : ImpulseEvent ) : void 		{			for each( var p : Particle in _particles )			{				p.x += p.velocity.x * e.biasInSeconds;				p.y += p.velocity.y * e.biasInSeconds;				p.velocity.x += particlesGravity.x * e.biasInSeconds;				p.velocity.y += particlesGravity.y * e.biasInSeconds;								p.velocity.x *= particlesFriction;				p.velocity.y *= particlesFriction;				p.life += e.bias;								if( p.life > p.maxLife )					delete _particles[p];			}
		}				protected function draw () : void		{			graphics.clear();			 			for( var i : Number = 0; i < segmentCount; i++ )			{				drawSegment( path.getPathPoint( i/segmentCount ),							 path.getPathPoint( (i + 1) / segmentCount ) );			}			if( _particles )  				drawParticles();		}		protected function drawParticles () : void 		{			graphics.lineStyle();						for each( var p : Particle in _particles )			{				graphics.beginFill( lineColor.hexa, Cubic.easeIn(p.life, 1, -1, p.maxLife) );				graphics.drawCircle( p.x , p.y, p.radius );				graphics.endFill();			}		}
		protected function drawSegment ( pt1 : Point, pt2 : Point )  : void		{			var start : Point = pt1.clone();			var length : Number = pt2.subtract( start ).length / segmentCount;			graphics.lineStyle( lineThickness, lineColor.hexa );			graphics.moveTo( start.x, start.y );						for( var i : Number = 0; i < subSegmentCount - 1; i++ )			{				var segment : Point = pt2.subtract( start );				segment.normalize( length );				segment = _randomSource.ipoint( segment, randomAmount );								graphics.lineTo( start.x + segment.x, 								 start.y + segment.y );								 				if( _randomSource.boolean( particlesRate ) )				{					var l : uint = 1+_randomSource.irandom(particlesSalveCount);					while(l--)						{						var p : Particle = new Particle( start.x, 														 start.y, 														 _randomSource.rangeAB( particlesLifeMin, particlesLifeMax ), 														 _randomSource.rangeAB( particlesRadiusMin, particlesRadiusMax ), 														 _randomSource.velocity(0, MathUtils.PI2, particlesVelocityMin, particlesVelocityMax ) );						_particles[p] = p;					}				}								start = start.add( segment );			}			graphics.lineTo( pt2.x, pt2.y );		}	}}import abe.com.mon.geom.pt;import flash.geom.Point;internal class Particle {	public var life : Number;	public var maxLife : Number;	public var x : Number;	public var y : Number;	public var radius : Number;	public var velocity : Point;
	public function Particle( 							  x : Number = 0,							  y : Number = 0,							  maxLife : Number = 100,							  radius : Number = 4,							  velocity : Point = null							)	{		this.maxLife = maxLife;		this.y = y;		  		this.x = x;		  		this.life = 0;				this.radius = radius; 			this.velocity = velocity ? velocity : pt();	}}